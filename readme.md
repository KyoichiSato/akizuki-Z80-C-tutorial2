# 秋月電子で売っている Z80用 Cコンパイラ XCC-Vで CP/M / MSX-DOS で動くプログラムを作る
[秋月電子で売っている Z80用 Cコンパイラ XCC-Vの使い方](https://github.com/KyoichiSato/akizuki-Z80-C-tutorial1) の続きです。

前回 Cのソースを、コンパイル - アセンブル - リンクして実行可能なバイナリ情報を出力できるようになりました。
今回は CP/M / MSX-DOS で動作するプログラムを作ってみます。

MSX-DOSは CP/Mとファンクションコールが上位互換で、
MSX-DOSで CP/Mのプログラム動作します。この文章本文では CP/Mと表記していますが、
MSX-DOSでも同じように動作します。

## 目次
1. [CP/M / MSX-DOSから起動できるようにする](#CP/M-/-MSX-DOSから起動できるようにする)
1. [BDOSコールを C言語から使えるようにする](#BDOSコールを-C言語から使えるようにする)
1. [Intel HEX形式を COM形式に変換](#Intel-HEX形式を-COM形式に変換)
1. [ビルドする](#ビルドする)
1. [CP/M のシステムコールの資料](#CP/M-のシステムコールの資料)
1. [この文章のライセンス](#ライセンス)

#### 別頁
- [秋月電子で売っている Z80用 Cコンパイラ XCC-Vの使い方](https://github.com/KyoichiSato/akizuki-Z80-C-tutorial1)
- [CP/M / MSX-DOSで標準入出力とファイル入出力を使えるようにする]()

------

## CP/M / MSX-DOSから起動できるようにする
### リンクパラメータファイルの編集
CP/Mのプログラムはアドレス `0x0100`番地にロードされて実行されるので、プログラムが `0x0100`
 番地から配置されるようにリンクパラメータファイルを編集します。

#### tutorial_2.xls
```
;-------------------------------+
;       RAM Area                |
;-------------------------------+
; CP/Mなので全部RAMに配置
/ADDR=0100
/SECT=C_START   ; 0100Hからスタートアッププログラムを配置
/SECT=C_*|CODE
/SECT=I_*
/SECT=D_*|COMM          (data   =_DATA)
/SECT=B_*|COMM          (bss    =_BSS)
/init_section = _INIT_DATA      (_DATA)
/SECT=_STACK

;-------------------------------+
;       linkage module          |
;-------------------------------+
/Syslib=C:\akiz80\LIB\z80\CS\CSZE1.XLB          ; 基本？ライブラリ（計算や最適化で呼び出される）
/Syslib=C:\akiz80\LIB\z80\STD\STDZE1.XLB        ; C言語の標準ライブラリ
/Syslib=C:\akiz80\LIB\z80\MATH\MATZE1.XLB       ; 数学ライブラリ
;リンカがかしこくて、システムライブラリは使用する関数のみリンクされる。
;使用しない分はリンクされないので、システムライブラリは指定しっぱなしでよい。

/Name=tutorial_2        ; 出力オブジェクト名
/Entry_Name=startup     ; 実行開始オブジェクト名

; リンクするオブジェクトを列記する。拡張子を省略すると ".xao"
/Module=startup
/Module=tutorial_2
/Module=cpm
```
すべてのセクションを RAMに配置しています。
マニュアルに CP/Mのことは何も書かれていないのですが、やってみると簡単でした。

### スタートアッププログラム
CP/M のファンクションコール (BDOSコール) の動作確認で文字を表示してみます。

まずは、なるべく簡単に実行してみたかったので、
アセンブリで書かれているスタートアッププログラムに直接追記して文字を表示させてみました。

#### startup.xas
```
（略）
;*** call main ***  main 関数の起動

        ; 動作確認で文字を出力してみる
        ld	C,09H	; CP/M 文字列出力
        ld	DE,STR1$        ; 最後に '$' を付けるとローカルラベル
        call	0005H	; BDOS CALL


        extnal  _main
        call    _main	; main関数実行

        ld	C,09H	; CP/M 文字列出力
        ld	DE,STR2$
        call	0005H	; BDOS CALL

        jp	0	; CP/M ウォームスタート
STR1$:	db	'call main',0DH,0AH,'$' ; 0DH:CR 0AH:LF 文字列の終端記号は '$'
STR2$:	db	0DH,0AH,'end main$'
```
main関数呼び出しの前後に文字列表示を追加しました。
こんな簡単な変更で、ちゃんと文字が表示されました。

------

## BDOSコールを C言語から使えるようにする
アセンブリ言語のプログラムから CP/Mのシステムコールを使って文字列を表示することができたので、
こんどは C言語から CP/Mのシステムコールを使えるようにします。

CPUのレジスタに値をセットして特定のアドレスをコールするには、アセンブリ言語でプログラムを書く必要があります。
このコンパイラでは C言語のプログラムの中でインラインアセンブラも使えるのですが、
Cの変数を簡単に参照する方法を見つけられなかったので、
アセンブリ言語で書いた関数を C言語から呼び出すことにしました。

C言語からアセンブリ言語のプログラムを呼び出したり、
逆にアセンブリ言語のプログラムからC言語のプログラムを呼び出したりする方法は、
Cコンパイラのマニュアルの「アセンブラモジュールとの結合」に書かれていましたので、
ここに簡単にまとめておきます。

### C言語からアセンブリ言語で書かれた関数を呼び出す場合

### アセンブリ言語から C言語で書かれた関数を呼び出す場合

------

## Intel HEX形式を COM形式に変換
------
## ビルドする
------
## CP/M のシステムコールの資料

------

## ライセンス
この文章とサンプルコードは、CC0 Public Domain License で提供します。
https://creativecommons.org/publicdomain/zero/1.0/

2025年2月5日 佐藤恭一 kyoutan.jpn.org
